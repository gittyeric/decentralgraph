# DO NOT MODIFY DIRECTLY, this is copied from: "https://github.com/ledgerwatch/erigon/blob/devel/docker-compose.yml"
#

# Erigon by default is "all in one binary" solution, but it's possible start TxPool as separated processes.
# Same true about: JSON RPC layer (RPCDaemon), p2p layer (Sentry), history download layer (Downloader), consensus.
# Don't start services as separated processes unless you have clear reason for it: resource limiting, scale, replace by your own implementation, security.
# This file is an example: how to start Erigon's services as separated processes.

# Default: --datadir=/home/erigon/.local/share/erigon
# Default UID: 1000
# Default GID: 1000
# Ports: `9090` execution engine (private api), `9091` sentry, `9092` consensus engine, `9093` snapshot downloader, `9094` TxPool
# Ports: `8545` json rpc, `8551` consensus json rpc, `30303` eth p2p protocol, `42069` bittorrent protocol,

# Connections: erigon -> (sentries, downloader), rpcdaemon -> (erigon, txpool), txpool -> erigon

version: '3.8'

# Basic erigon's service
x-erigon-service:
  &default-erigon-service
  image: thorax/erigon:$ERIGON_TAG
  pid: service:erigon # Use erigon's PID namespace. It's required to open Erigon's DB from another process (RPCDaemon local-mode)
  volumes_from: [ erigon ]
  restart: unless-stopped
  mem_swappiness: 0
  user: ${DOCKER_UID:-1000}:${DOCKER_GID:-1000}

services:
  # ------------ General Services ------------------

  lighthouse:
    &lighthouse
    network_mode: "host"
    image: sigp/lighthouse:$LIGHTHOUSE_TAG
    volumes:
      - ${LIGHTHOUSE_DATA_HOME}:/root/.lighthouse
      - ${LIGHTHOUSE_DATA_HOME}:/home/lighthouse/.local/share/lighthouse
    ports:
      - 5052:5052/tcp
      - 5053:5053/tcp
      - 5054:5054/tcp # metrics endpoint
      - 9000:9000/tcp
      - 9000:9000/udp
    environment:
      - NETWORK=none
    env_file:
      - .env
    command: lighthouse --network $$NETWORK beacon_node --execution-endpoint http://0.0.0.0:8551 --execution-jwt /opt/jwt.hex
    restart: unless-stopped
    mem_swappiness: 0
    profiles:
      - none

  erigon:
    &erigon
    network_mode: "host"
    image: thorax/erigon:$ERIGON_TAG
    pid: service:erigon
    environment:
      - NETWORK=goerli
    #build:
    #  args:
    #    UID: ${DOCKER_UID:-1000}
    #    GID: ${DOCKER_GID:-1000}
    #  context: .
    command:
      [
        "--chain=goerli", # TODO: fix!!!!
        '--torrent.download.rate=20mb',
        '--authrpc.addr=0.0.0.0',
        '--authrpc.vhosts=0.0.0.0',
        '--http.addr=0.0.0.0',
        '--http.vhosts=*',
        '--http.corsdomain=*',
        '--ws',
        '--private.api.addr=0.0.0.0:9090',
        '--txpool.api.addr=txpool:9094',
        '--sentry.api.addr=0.0.0.0:9091',
        '--downloader.api.addr=0.0.0.0:9093',
        #'--metrics',
      #'--metrics.addr=0.0.0.0',
      #'--metrics.port=6060',
        '--pprof',
        '--pprof.addr=0.0.0.0',
        '--pprof.port=6061',
        '--authrpc.jwtsecret=/home/erigon/.local/share/erigon/jwt.hex',
        '--datadir=/home/erigon/.local/share/erigon'
      ]
    ports:
      [
        "8551:8551",
        "8545:8545",
        "9090:9090",
        "9091:9091",
        "9093:9093",
        "9094:9094",
        "30303:30303/tcp",
        "30303:30303/udp",
        "42069:42069/tcp",
        "42069:42069/udp"
      ]
    volumes:
      # It's ok to mount sub-dirs of "datadir" to different drives
      - ${ERIGON_DATA_HOME}:/home/erigon/.local/share/erigon
      #- type: bind
      #  source: ${EXEC_TOKEN_DIR}
      #  target: /home/erigon/.local/share/erigon
      #  read_only: true
    restart: unless-stopped
    mem_swappiness: 0
    profiles:
      - none

  core:
    &core
    network_mode: "host"
    image: dg-backend
    volumes:
      - ${CORE_DATA_HOME}:/home/core
    environment:
      - SERVICE=core
      - NETWORK=none
    build:
      dockerfile: backend.Dockerfile
    restart: unless-stopped
    mem_swappiness: 0
    profiles:
      - none

  bridge:
    depends_on:
      - core
    network_mode: "host"
    image: dg-backend
    environment:
      - SERVICE=bridge
    build:
      dockerfile: backend.Dockerfile
    ports: [ "${BRIDGE_PORT}:80" ]
    restart: unless-stopped
    profiles:
      - webapp

  frontend:
    depends_on:
      - bridge
    network_mode: "host"
    image: dg-frontend
    build:
      dockerfile: frontend.Dockerfile
    restart: unless-stopped
    ports:
      - ${FRONTEND_PORT}:8080/tcp
    profiles:
      - goerli0
      - mainnet

  # Edge caching service is disabled by default
  edge:
    network_mode: "host"
    image: dg-backend
    build:
      dockerfile: frontend.Dockerfile
    environment:
      - SERVICE=edge
    restart: unless-stopped
    ports: [ "${EDGE_PORT}:80" ]
    profiles:
      - edge

  #-------------- Services by chain

  # Goerli

  core-goerli:
    depends_on:
      - lighthouse-goerli
      - erigon-goerli
    <<: *core
    environment:
      - NETWORK=goerli
    profiles:
      - goerli0

  erigon-goerli:
    <<: *erigon
    environment:
      - NETWORK=goerli
    profiles:
      - goerli
      - test

  lighthouse-goerli:
    <<: *lighthouse
    depends_on:
      - erigon-goerli
    environment:
      - NETWORK=goerli
    profiles:
      - goerli0
      - test

  # Mainnet

  core-mainnet:
    <<: *core
    depends_on:
      - lighthouse-mainnet
      - erigon-mainnet
    environment:
      - NETWORK=mainnet
    profiles:
      - mainnet

  erigon-mainnet:
    <<: *erigon
    environment:
      - NETWORK=mainnet
    profiles:
      - mainnet

  lighthouse-mainnet:
    <<: *lighthouse
    depends_on:
      - erigon-mainnet
    environment:
      - NETWORK=mainnet
    profiles:
      - mainnet
